# 后端扩展性设计

> 版本：v1.0
> 更新时间：2025-01-15
> 优先级：P0（架构级）

## 1. 设计目标

### 1.1 核心原则

1. **开闭原则**：对扩展开放，对修改关闭
2. **单一职责**：每个扩展点只关注一个特定功能
3. **依赖倒置**：依赖抽象而非具体实现
4. **可配置化**：扩展逻辑可通过配置动态启用/禁用

### 1.2 扩展性需求

| 需求 | 说明 | 优先级 |
|------|------|--------|
| Flowable API 封装 | 统一封装 Flowable 引擎 API，支持调用前后扩展 | P0 |
| 流程事件扩展 | 事件触发前后支持扩展逻辑 | P0 |
| 节点提交组合逻辑 | 不同节点类型间的流转逻辑可扩展 | P0 |
| 自定义扩展点 | 允许业务添加自定义扩展 | P1 |

---

## 2. Flowable API 封装设计

### 2.1 设计思路

通过 **装饰器模式 + 模板方法模式** 封装 Flowable API，在调用前后插入扩展点。

### 2.2 核心接口

#### 2.2.1 FlowableService 包装器接口

```java
/**
 * Flowable 服务包装器基础接口
 */
public interface FlowableServiceWrapper {

    /**
     * 前置处理
     */
    default void before(String operation, Object... args) {
        // 默认不做处理
    }

    /**
     * 后置处理
     */
    default void after(String operation, Object result, Object... args) {
        // 默认不做处理
    }

    /**
     * 异常处理
     */
    default void onException(String operation, Exception e, Object... args) {
        // 默认抛出异常
        throw new RuntimeException(e);
    }
}
```

#### 2.2.2 服务执行模板

```java
/**
 * Flowable 服务执行模板
 */
@Component
public class FlowableServiceTemplate {

    @Autowired
    private List<FlowableServiceWrapper> wrappers;

    /**
     * 执行服务方法
     */
    public <T> T execute(
        String operation,
        Supplier<T> serviceMethod,
        Object... args
    ) {
        // 1. 前置处理
        for (FlowableServiceWrapper wrapper : wrappers) {
            wrapper.before(operation, args);
        }

        try {
            // 2. 执行原方法
            T result = serviceMethod.get();

            // 3. 后置处理
            for (FlowableServiceWrapper wrapper : wrappers) {
                wrapper.after(operation, result, args);
            }

            return result;

        } catch (Exception e) {
            // 4. 异常处理
            for (FlowableServiceWrapper wrapper : wrappers) {
                wrapper.onException(operation, e, args);
            }
            throw e;
        }
    }
}
```

### 2.3 具体服务封装

#### 2.3.1 RepositoryService 封装

```java
/**
 * 流程定义服务封装
 */
@Service
public class ExtendedRepositoryService {

    @Autowired
    private RepositoryService flowableRepositoryService;

    @Autowired
    private FlowableServiceTemplate serviceTemplate;

    /**
     * 部署流程定义
     */
    public Deployment deploy(String deploymentName, InputStream bpmnStream) {
        return serviceTemplate.execute(
            "RepositoryService.deploy",
            () -> flowableRepositoryService.createDeployment()
                .name(deploymentName)
                .addInputStream("process.bpmn20.xml", bpmnStream)
                .deploy(),
            deploymentName, bpmnStream
        );
    }

    /**
     * 创建流程定义查询
     */
    public ProcessDefinitionQuery createProcessDefinitionQuery() {
        return serviceTemplate.execute(
            "RepositoryService.createProcessDefinitionQuery",
            () -> flowableRepositoryService.createProcessDefinitionQuery()
        );
    }

    /**
     * 删除部署
     */
    public void deleteDeployment(
        String deploymentId,
        boolean cascade,
        boolean skipCustomListeners
    ) {
        serviceTemplate.execute(
            "RepositoryService.deleteDeployment",
            () -> {
                flowableRepositoryService.deleteDeployment(
                    deploymentId,
                    cascade,
                    skipCustomListeners
                );
                return null;
            },
            deploymentId, cascade, skipCustomListeners
        );
    }
}
```

#### 2.3.2 RuntimeService 封装

```java
/**
 * 流程运行时服务封装
 */
@Service
public class ExtendedRuntimeService {

    @Autowired
    private RuntimeService flowableRuntimeService;

    @Autowired
    private FlowableServiceTemplate serviceTemplate;

    /**
     * 启动流程实例
     */
    public ProcessInstance startProcessInstanceByKey(
        String processDefinitionKey,
        String businessKey,
        Map<String, Object> variables
    ) {
        return serviceTemplate.execute(
            "RuntimeService.startProcessInstanceByKey",
            () -> flowableRuntimeService.startProcessInstanceByKey(
                processDefinitionKey,
                businessKey,
                variables
            ),
            processDefinitionKey, businessKey, variables
        );
    }

    /**
     * 删除流程实例
     */
    public void deleteProcessInstance(
        String processInstanceId,
        String deleteReason
    ) {
        serviceTemplate.execute(
            "RuntimeService.deleteProcessInstance",
            () -> {
                flowableRuntimeService.deleteProcessInstance(
                    processInstanceId,
                    deleteReason
                );
                return null;
            },
            processInstanceId, deleteReason
        );
    }

    /**
     * 挂起流程实例
     */
    public void suspendProcessInstanceById(String processInstanceId) {
        serviceTemplate.execute(
            "RuntimeService.suspendProcessInstanceById",
            () -> {
                flowableRuntimeService.suspendProcessInstanceById(
                    processInstanceId
                );
                return null;
            },
            processInstanceId
        );
    }

    /**
     * 激活流程实例
     */
    public void activateProcessInstanceById(String processInstanceId) {
        serviceTemplate.execute(
            "RuntimeService.activateProcessInstanceById",
            () -> {
                flowableRuntimeService.activateProcessInstanceById(
                    processInstanceId
                );
                return null;
            },
            processInstanceId
        );
    }

    /**
     * 设置流程变量
     */
    public void setVariable(
        String processInstanceId,
        String variableName,
        Object value
    ) {
        serviceTemplate.execute(
            "RuntimeService.setVariable",
            () -> {
                flowableRuntimeService.setVariable(
                    processInstanceId,
                    variableName,
                    value
                );
                return null;
            },
            processInstanceId, variableName, value
        );
    }
}
```

#### 2.3.3 TaskService 封装

```java
/**
 * 任务服务封装
 */
@Service
public class ExtendedTaskService {

    @Autowired
    private TaskService flowableTaskService;

    @Autowired
    private FlowableServiceTemplate serviceTemplate;

    /**
     * 完成任务
     */
    public void complete(
        String taskId,
        Map<String, Object> variables
    ) {
        serviceTemplate.execute(
            "TaskService.complete",
            () -> {
                flowableTaskService.complete(taskId, variables);
                return null;
            },
            taskId, variables
        );
    }

    /**
     * 创建任务查询
     */
    public TaskQuery createTaskQuery() {
        return serviceTemplate.execute(
            "TaskService.createTaskQuery",
            () -> flowableTaskService.createTaskQuery()
        );
    }

    /**
     * 设置任务候选人
     */
    public void addCandidateUser(
        String taskId,
        String userId
    ) {
        serviceTemplate.execute(
            "TaskService.addCandidateUser",
            () -> {
                flowableTaskService.addCandidateUser(taskId, userId);
                return null;
            },
            taskId, userId
        );
    }

    /**
     * 设置任务受理人
     */
    public void setAssignee(String taskId, String userId) {
        serviceTemplate.execute(
            "TaskService.setAssignee",
            () -> {
                flowableTaskService.setAssignee(taskId, userId);
                return null;
            },
            taskId, userId
        );
    }
}
```

### 2.4 内置包装器实现

#### 2.4.1 日志记录包装器

```java
/**
 * 日志记录包装器
 */
@Component
@Order(1)
public class LoggingWrapper implements FlowableServiceWrapper {

    private static final Logger logger = LoggerFactory.getLogger(LoggingWrapper.class);

    @Override
    public void before(String operation, Object... args) {
        if (logger.isDebugEnabled()) {
            logger.debug("Flowable operation [{}] started with args: {}",
                operation, Arrays.toString(args));
        }
    }

    @Override
    public void after(String operation, Object result, Object... args) {
        if (logger.isDebugEnabled()) {
            logger.debug("Flowable operation [{}] completed with result: {}",
                operation, result);
        }
    }

    @Override
    public void onException(String operation, Exception e, Object... args) {
        logger.error("Flowable operation [{}] failed", operation, e);
    }
}
```

#### 2.4.2 性能监控包装器

```java
/**
 * 性能监控包装器
 */
@Component
@Order(2)
public class PerformanceMonitoringWrapper implements FlowableServiceWrapper {

    private static final Logger logger = LoggerFactory.getLogger(
        PerformanceMonitoringWrapper.class
    );

    private final ThreadLocal<Long> startTime = new ThreadLocal<>();

    @Override
    public void before(String operation, Object... args) {
        startTime.set(System.currentTimeMillis());
    }

    @Override
    public void after(String operation, Object result, Object... args) {
        Long start = startTime.get();
        if (start != null) {
            long duration = System.currentTimeMillis() - start;
            logger.info("Operation [{}] took {} ms", operation, duration);

            // 如果耗时超过阈值，记录警告
            if (duration > 1000) {
                logger.warn("Operation [{}] took too long: {} ms", operation, duration);
            }
        }
        startTime.remove();
    }

    @Override
    public void onException(String operation, Exception e, Object... args) {
        startTime.remove();
    }
}
```

#### 2.4.3 事件发布包装器

```java
/**
 * 事件发布包装器
 */
@Component
@Order(3)
public class EventPublishingWrapper implements FlowableServiceWrapper {

    @Autowired
    private ApplicationEventPublisher eventPublisher;

    @Override
    public void before(String operation, Object... args) {
        // 发布操作前事件
        FlowableOperationBeforeEvent event =
            new FlowableOperationBeforeEvent(operation, args);
        eventPublisher.publishEvent(event);
    }

    @Override
    public void after(String operation, Object result, Object... args) {
        // 发布操作后事件
        FlowableOperationAfterEvent event =
            new FlowableOperationAfterEvent(operation, result, args);
        eventPublisher.publishEvent(event);
    }
}
```

#### 2.4.4 权限检查包装器

```java
/**
 * 权限检查包装器
 */
@Component
@Order(4)
public class PermissionCheckWrapper implements FlowableServiceWrapper {

    @Autowired
    private PermissionService permissionService;

    @Override
    public void before(String operation, Object... args) {
        // 根据操作类型检查权限
        switch (operation) {
            case "RuntimeService.startProcessInstanceByKey":
                permissionService.checkProcessStartPermission(
                    (String) args[0] // processDefinitionKey
                );
                break;
            case "TaskService.complete":
                permissionService.checkTaskCompletePermission(
                    (String) args[0] // taskId
                );
                break;
            // 其他操作...
        }
    }
}
```

---

## 3. 流程事件机制扩展设计

### 3.1 事件监听器接口

```java
/**
 * 流程事件监听器接口
 */
public interface ProcessEventListener {

    /**
     * 事件触发前
     */
    default void onBefore(ProcessEvent event) {
        // 默认不做处理
    }

    /**
     * 事件触发后
     */
    default void onAfter(ProcessEvent event) {
        // 默认不做处理
    }

    /**
     * 判断是否支持该事件
     */
    boolean supports(String eventType);
}
```

### 3.2 事件定义

```java
/**
 * 流程事件
 */
@Data
@AllArgsConstructor
public class ProcessEvent {

    /**
     * 事件类型
     */
    private String eventType;

    /**
     * 流程实例ID
     */
    private String processInstanceId;

    /**
     * 流程定义ID
     */
    private String processDefinitionId;

    /**
     * 任务ID（如果适用）
     */
    private String taskId;

    /**
     * 活动ID（如果适用）
     */
    private String activityId;

    /**
     * 事件数据
     */
    private Map<String, Object> data;

    /**
     * 触发时间
     */
    private LocalDateTime triggerTime;

    /**
     * 获取数据
     */
    public <T> T getData(String key, Class<T> type) {
        Object value = data.get(key);
        return value != null ? (T) value : null;
    }
}
```

### 3.3 事件管理器

```java
/**
 * 流程事件管理器
 */
@Component
public class ProcessEventManager {

    @Autowired
    private List<ProcessEventListener> listeners;

    /**
     * 触发事件
     */
    public void triggerEvent(ProcessEvent event) {
        // 1. 事件触发前
        for (ProcessEventListener listener : listeners) {
            if (listener.supports(event.getEventType())) {
                listener.onBefore(event);
            }
        }

        try {
            // 2. 执行事件业务逻辑（如有）
            doExecute(event);

            // 3. 事件触发后
            for (ProcessEventListener listener : listeners) {
                if (listener.supports(event.getEventType())) {
                    listener.onAfter(event);
                }
            }

        } catch (Exception e) {
            // 异常处理
            handleEventException(event, e);
            throw e;
        }
    }

    private void doExecute(ProcessEvent event) {
        // 事件具体执行逻辑
    }

    private void handleEventException(ProcessEvent event, Exception e) {
        // 异常处理逻辑
    }
}
```

### 3.4 标准事件监听器实现

#### 3.4.1 流程启动监听器

```java
/**
 * 流程启动监听器
 */
@Component
public class ProcessStartListener implements ProcessEventListener {

    @Autowired
    private AuditLogService auditLogService;

    @Autowired
    private NotificationService notificationService;

    @Override
    public void onBefore(ProcessEvent event) {
        String processInstanceId = event.getProcessInstanceId();
        String startUser = event.getData("startUser", String.class);

        // 记录审计日志
        auditLogService.log(
            processInstanceId,
            "PROCESS_START",
            startUser,
            "流程启动"
        );
    }

    @Override
    public void onAfter(ProcessEvent event) {
        String processInstanceId = event.getProcessInstanceId();
        String startUser = event.getData("startUser", String.class);

        // 发送通知
        notificationService.sendProcessStartNotification(
            processInstanceId,
            startUser
        );
    }

    @Override
    public boolean supports(String eventType) {
        return "PROCESS_START".equals(eventType);
    }
}
```

#### 3.4.2 任务创建监听器

```java
/**
 * 任务创建监听器
 */
@Component
public class TaskCreatedListener implements ProcessEventListener {

    @Autowired
    private EmailService emailService;

    @Autowired
    private TaskTimeoutMonitor timeoutMonitor;

    @Override
    public void onBefore(ProcessEvent event) {
        String taskId = event.getTaskId();
        String assignee = event.getData("assignee", String.class);
        String taskName = event.getData("taskName", String.class);

        // 记录审计日志
        auditLogService.log(
            event.getProcessInstanceId(),
            "TASK_CREATED",
            assignee,
            "任务创建: " + taskName
        );
    }

    @Override
    public void onAfter(ProcessEvent event) {
        String taskId = event.getTaskId();
        String assignee = event.getData("assignee", String.class);
        String taskName = event.getData("taskName", String.class);

        // 发送邮件通知
        emailService.sendTaskAssignmentEmail(
            assignee,
            taskName,
            event.getProcessInstanceId()
        );

        // 启动超时监控
        timeoutMonitor.startMonitoring(taskId);
    }

    @Override
    public boolean supports(String eventType) {
        return "TASK_CREATED".equals(eventType);
    }
}
```

### 3.5 自定义事件监听器配置

```java
/**
 * 自定义事件监听器注册器
 */
@Configuration
public class CustomEventListenerRegistrar {

    @Autowired
    private ProcessEventManager eventManager;

    /**
     * 注册自定义监听器
     */
    @PostConstruct
    public void registerCustomListeners() {
        // 从配置文件或数据库加载自定义监听器
        List<EventListenerConfig> configs = loadListenerConfigs();

        for (EventListenerConfig config : configs) {
            if (config.isEnabled()) {
                ProcessEventListener listener = createListener(config);
                eventManager.addListener(listener);
            }
        }
    }

    private ProcessEventListener createListener(EventListenerConfig config) {
        // 根据配置创建监听器实例
        try {
            Class<?> clazz = Class.forName(config.getListenerClass());
            return (ProcessEventListener) clazz.getDeclaredConstructor()
                .newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Failed to create listener", e);
        }
    }
}
```

---

## 4. 任务提交组合逻辑设计

### 4.1 设计思路

使用 **责任链模式 + 策略模式** 实现不同节点类型间的流转逻辑。

### 4.2 节点类型定义

```java
/**
 * 节点类型枚举
 */
public enum NodeType {

    /**
     * 用户任务
     */
    USER_TASK("userTask", "用户任务"),

    /**
     * 服务任务
     */
    SERVICE_TASK("serviceTask", "服务任务"),

    /**
     * 脚本任务
     */
    SCRIPT_TASK("scriptTask", "脚本任务"),

    /**
     * 排他网关
     */
    EXCLUSIVE_GATEWAY("exclusiveGateway", "排他网关"),

    /**
     * 并行网关
     */
    PARALLEL_GATEWAY("parallelGateway", "并行网关"),

    /**
     * 包容网关
     */
    INCLUSIVE_GATEWAY("inclusiveGateway", "包容网关"),

    /**
     * 调用活动（子流程）
     */
    CALL_ACTIVITY("callActivity", "调用活动"),

    /**
     * 多实例
     */
    MULTI_INSTANCE("multiInstance", "多实例");

    private final String code;
    private final String name;

    NodeType(String code, String name) {
        this.code = code;
        this.name = name;
    }
}
```

### 4.3 提交上下文

```java
/**
 * 任务提交上下文
 */
@Data
@Builder
public class TaskCompletionContext {

    /**
     * 当前任务ID
     */
    private String taskId;

    /**
     * 当前节点类型
     */
    private NodeType currentNodeType;

    /**
     * 流程实例ID
     */
    private String processInstanceId;

    /**
     * 流程变量
     */
    private Map<String, Object> variables;

    /**
     * 审批意见
     */
    private String comment;

    /**
     * 下一个节点信息
     */
    private List<NodeInfo> nextNodes;

    /**
     * 扩展数据
     */
    private Map<String, Object> extendedData;

    @Data
    @Builder
    public static class NodeInfo {
        private String nodeId;
        private String nodeName;
        private NodeType nodeType;
        private Map<String, Object> properties;
    }
}
```

### 4.4 提交处理器接口

```java
/**
 * 任务提交处理器接口
 */
public interface TaskCompletionHandler {

    /**
     * 是否支持处理
     */
    boolean supports(TaskCompletionContext context);

    /**
     * 前置处理
     */
    void preHandle(TaskCompletionContext context);

    /**
     * 处理提交
     */
    void handle(TaskCompletionContext context);

    /**
     * 后置处理
     */
    void postHandle(TaskCompletionContext context);

    /**
     * 处理器优先级（数字越小优先级越高）
     */
    default int getOrder() {
        return 0;
    }
}
```

### 4.5 提交处理器链

```java
/**
 * 任务提交处理器链
 */
@Component
public class TaskCompletionHandlerChain {

    @Autowired
    private List<TaskCompletionHandler> handlers;

    /**
     * 执行提交处理
     */
    public void execute(TaskCompletionContext context) {
        // 1. 按优先级排序处理器
        handlers.sort(Comparator.comparingInt(TaskCompletionHandler::getOrder));

        // 2. 找到支持的处理器
        List<TaskCompletionHandler> supportedHandlers = handlers.stream()
            .filter(handler -> handler.supports(context))
            .collect(Collectors.toList());

        if (supportedHandlers.isEmpty()) {
            throw new NoHandlerFoundException(
                "No handler found for context: " + context
            );
        }

        // 3. 前置处理
        for (TaskCompletionHandler handler : supportedHandlers) {
            handler.preHandle(context);
        }

        try {
            // 4. 执行处理
            for (TaskCompletionHandler handler : supportedHandlers) {
                handler.handle(context);
            }

            // 5. 后置处理
            for (TaskCompletionHandler handler : supportedHandlers) {
                handler.postHandle(context);
            }

        } catch (Exception e) {
            // 异常回滚处理
            rollbackOnException(context, supportedHandlers);
            throw e;
        }
    }

    private void rollbackOnException(
        TaskCompletionContext context,
        List<TaskCompletionHandler> handlers
    ) {
        // 逆序执行回滚
        List<TaskCompletionHandler> reversed = new ArrayList<>(handlers);
        Collections.reverse(reversed);

        for (TaskCompletionHandler handler : reversed) {
            try {
                handler.rollback(context);
            } catch (Exception e) {
                // 记录错误，继续回滚
            }
        }
    }
}
```

### 4.6 具体处理器实现

#### 4.6.1 用户任务 → 用户任务处理器

```java
/**
 * 用户任务到用户任务处理器
 */
@Component
public class UserTaskToUserTaskHandler implements TaskCompletionHandler {

    @Autowired
    private ExtendedTaskService taskService;

    @Override
    public boolean supports(TaskCompletionContext context) {
        return context.getCurrentNodeType() == NodeType.USER_TASK
            && context.getNextNodes().stream()
                .anyMatch(node -> node.getNodeType() == NodeType.USER_TASK);
    }

    @Override
    public void preHandle(TaskCompletionContext context) {
        // 1. 验证必填项
        validateRequiredFields(context);

        // 2. 记录审批意见
        saveComment(context);

        // 3. 更新流程变量
        updateVariables(context);
    }

    @Override
    public void handle(TaskCompletionContext context) {
        // 直接完成任务
        taskService.complete(context.getTaskId(), context.getVariables());
    }

    @Override
    public void postHandle(TaskCompletionContext context) {
        // 发送通知给下一节点处理人
        notifyNextAssignees(context);

        // 记录审计日志
        auditLogService.log(
            context.getProcessInstanceId(),
            "TASK_COMPLETE",
            SecurityContextHolder.getContext().getAuthentication().getName(),
            context.getComment()
        );
    }

    @Override
    public int getOrder() {
        return 1;
    }
}
```

#### 4.6.2 用户任务 → 并行网关处理器

```java
/**
 * 用户任务到并行网关处理器
 */
@Component
public class UserTaskToParallelGatewayHandler implements TaskCompletionHandler {

    @Autowired
    private ExtendedTaskService taskService;

    @Autowired
    private ParallelGatewayHandler gatewayHandler;

    @Override
    public boolean supports(TaskCompletionContext context) {
        return context.getCurrentNodeType() == NodeType.USER_TASK
            && context.getNextNodes().stream()
                .anyMatch(node -> node.getNodeType() == NodeType.PARALLEL_GATEWAY);
    }

    @Override
    public void preHandle(TaskCompletionContext context) {
        // 1. 验证并行分支条件
        gatewayHandler.validateBranches(context);

        // 2. 准备各分支变量
        gatewayHandler.prepareBranchVariables(context);
    }

    @Override
    public void handle(TaskCompletionContext context) {
        // 完成当前任务，触发并行网关
        taskService.complete(context.getTaskId(), context.getVariables());
    }

    @Override
    public void postHandle(TaskCompletionContext context) {
        // 记录并行分支创建日志
        gatewayHandler.logBranchesCreated(context);

        // 监控并行分支执行情况
        gatewayHandler.monitorBranches(context);
    }

    @Override
    public int getOrder() {
        return 2;
    }
}
```

#### 4.6.3 多实例 → 子流程处理器

```java
/**
 * 多实例到子流程处理器
 */
@Component
public class MultiInstanceToCallActivityHandler implements TaskCompletionHandler {

    @Autowired
    private ExtendedTaskService taskService;

    @Autowired
    private SubProcessService subProcessService;

    @Override
    public boolean supports(TaskCompletionContext context) {
        boolean isMultiInstance = context.getCurrentNodeType() == NodeType.MULTI_INSTANCE;
        boolean hasNextCallActivity = context.getNextNodes().stream()
            .anyMatch(node -> node.getNodeType() == NodeType.CALL_ACTIVITY);

        return isMultiInstance && hasNextCallActivity;
    }

    @Override
    public void preHandle(TaskCompletionContext context) {
        // 1. 检查多实例是否全部完成
        if (!isAllInstancesCompleted(context)) {
            throw new RuntimeException("Not all instances completed");
        }

        // 2. 汇总多实例结果
        Map<String, Object> aggregatedResults = aggregateInstanceResults(context);
        context.getVariables().putAll(aggregatedResults);

        // 3. 准备子流程参数
        prepareSubProcessVariables(context);
    }

    @Override
    public void handle(TaskCompletionContext context) {
        // 完成多实例任务
        taskService.complete(context.getTaskId(), context.getVariables());
    }

    @Override
    public void postHandle(TaskCompletionContext context) {
        // 启动子流程
        NodeInfo callActivityNode = context.getNextNodes().stream()
            .filter(node -> node.getNodeType() == NodeType.CALL_ACTIVITY)
            .findFirst()
            .orElseThrow();

        subProcessService.startSubProcess(
            callActivityNode,
            context.getVariables()
        );
    }

    /**
     * 检查是否所有实例都已完成
     */
    private boolean isAllInstancesCompleted(TaskCompletionContext context) {
        String taskId = context.getTaskId();
        TaskEntity task = (TaskEntity) taskService.createTaskQuery()
            .taskId(taskId)
            .singleResult();

        int nrOfInstances = (int) task.getVariable("nrOfInstances");
        int nrOfCompletedInstances = (int) task.getVariable("nrOfCompletedInstances");

        return nrOfCompletedInstances == nrOfInstances;
    }

    /**
     * 汇总多实例结果
     */
    private Map<String, Object> aggregateInstanceResults(
        TaskCompletionContext context
    ) {
        // 实现汇总逻辑
        Map<String, Object> results = new HashMap<>();

        // 例如：汇总所有实例的审批结果
        List<String> instanceResults = getInstanceResults(context);
        results.put("instanceResults", instanceResults);

        // 判断最终结果（全部通过/任一通过）
        boolean allApproved = instanceResults.stream()
            .allMatch(result -> "approved".equals(result));
        results.put("finalResult", allApproved);

        return results;
    }
}
```

#### 4.6.4 会签完成处理器

```java
/**
 * 会签完成处理器
 */
@Component
public class CountersignCompletionHandler implements TaskCompletionHandler {

    @Autowired
    private CountersignService countersignService;

    @Autowired
    private ExtendedTaskService taskService;

    @Override
    public boolean supports(TaskCompletionContext context) {
        String taskId = context.getTaskId();
        return countersignService.isCountersignTask(taskId);
    }

    @Override
    public void preHandle(TaskCompletionContext context) {
        // 1. 保存会签记录
        countersignService.saveCountersignRecord(
            context.getTaskId(),
            context.getComment(),
            context.getVariables()
        );

        // 2. 检查会签条件是否满足
        CountersignResult result = countersignService.checkCountersignCondition(
            context.getTaskId()
        );

        context.getExtendedData().put("countersignResult", result);

        // 3. 如果会签未完成，阻止继续流转
        if (!result.isCompleted()) {
            throw new CountersignNotCompleteException(
                "会签未完成，当前进度: " + result.getCompletedCount()
                + "/" + result.getTotalCount()
            );
        }
    }

    @Override
    public void handle(TaskCompletionContext context) {
        CountersignResult result = context.getExtendedData()
            .get("countersignResult", CountersignResult.class);

        // 根据会签结果决定是否继续
        if (result.isApproved()) {
            // 会签通过，完成任务
            taskService.complete(context.getTaskId(), context.getVariables());
        } else {
            // 会签拒绝，终止流程或驳回
            handleCountersignRejected(context);
        }
    }

    @Override
    public void postHandle(TaskCompletionContext context) {
        // 通知所有会签参与人
        countersignService.notifyCountersignCompleted(
            context.getTaskId(),
            context.getExtendedData()
                .get("countersignResult", CountersignResult.class)
        );
    }

    @Override
    public int getOrder() {
        return 10; // 高优先级，会签逻辑优先处理
    }
}
```

### 4.7 提交处理器工厂

```java
/**
 * 任务提交处理器工厂
 */
@Component
public class TaskCompletionHandlerFactory {

    private final Map<NodeType, TaskCompletionHandler> handlerMap = new HashMap<>();

    @Autowired
    public TaskCompletionHandlerFactory(
        List<TaskCompletionHandler> handlers
    ) {
        // 自动注册所有处理器
        for (TaskCompletionHandler handler : handlers) {
            registerHandler(handler);
        }
    }

    /**
     * 注册处理器（根据注解自动识别支持的节点类型）
     */
    private void registerHandler(TaskCompletionHandler handler) {
        // 从注解获取支持的节点类型
        SupportedNodeTypes annotation = handler.getClass()
            .getAnnotation(SupportedNodeTypes.class);

        if (annotation != null) {
            for (NodeType nodeType : annotation.value()) {
                handlerMap.put(nodeType, handler);
            }
        }
    }

    /**
     * 获取处理器
     */
    public TaskCompletionHandler getHandler(NodeType nodeType) {
        return handlerMap.get(nodeType);
    }

    /**
     * 获取所有处理器
     */
    public List<TaskCompletionHandler> getAllHandlers() {
        return new ArrayList<>(handlerMap.values());
    }
}

/**
 * 支持的节点类型注解
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface SupportedNodeTypes {
    NodeType[] value();
}
```

### 4.8 提交服务整合

```java
/**
 * 任务提交服务
 */
@Service
public class TaskCompletionService {

    @Autowired
    private ExtendedTaskService taskService;

    @Autowired
    private TaskCompletionHandlerChain handlerChain;

    @Autowired
    private ProcessEventManager eventManager;

    /**
     * 提交任务
     */
    @Transactional
    public void completeTask(String taskId, CompleteTaskRequest request) {
        // 1. 获取任务信息
        Task task = taskService.createTaskQuery()
            .taskId(taskId)
            .singleResult();

        if (task == null) {
            throw new TaskNotFoundException(taskId);
        }

        // 2. 构建提交上下文
        TaskCompletionContext context = buildCompletionContext(
            task,
            request
        );

        // 3. 触发任务提交前事件
        eventManager.triggerEvent(new ProcessEvent(
            "TASK_COMPLETE_BEFORE",
            task.getProcessInstanceId(),
            null,
            taskId,
            null,
            Map.of("task", task, "request", request),
            LocalDateTime.now()
        ));

        // 4. 执行提交处理链
        handlerChain.execute(context);

        // 5. 触发任务提交后事件
        eventManager.triggerEvent(new ProcessEvent(
            "TASK_COMPLETE_AFTER",
            task.getProcessInstanceId(),
            null,
            taskId,
            null,
            Map.of("task", task, "context", context),
            LocalDateTime.now()
        ));
    }

    /**
     * 构建提交上下文
     */
    private TaskCompletionContext buildCompletionContext(
        Task task,
        CompleteTaskRequest request
    ) {
        // 获取当前节点类型
        NodeType currentNodeType = determineNodeType(task);

        // 获取下一个节点信息
        List<NodeInfo> nextNodes = getNextNodes(task);

        return TaskCompletionContext.builder()
            .taskId(task.getId())
            .currentNodeType(currentNodeType)
            .processInstanceId(task.getProcessInstanceId())
            .variables(request.getVariables())
            .comment(request.getComment())
            .nextNodes(nextNodes)
            .extendedData(new HashMap<>())
            .build();
    }

    /**
     * 确定节点类型
     */
    private NodeType determineNodeType(Task task) {
        // 通过 Flowable API 获取节点类型
        // 实现逻辑...
    }

    /**
     * 获取下一个节点信息
     */
    private List<NodeInfo> getNextNodes(Task task) {
        // 通过 Flowable API 获取流出节点
        // 实现逻辑...
    }
}
```

---

## 5. 扩展点配置

### 5.1 配置文件

```yaml
# application.yml

lingflow:
  extension:
    # 是否启用扩展
    enabled: true

    # Flowable API 包装器
    wrappers:
      logging:
        enabled: true
        order: 1
      performance:
        enabled: true
        order: 2
      event-publishing:
        enabled: true
        order: 3
      permission-check:
        enabled: true
        order: 4

    # 事件监听器
    event-listeners:
      process-start:
        enabled: true
        class: com.lingflow.listener.ProcessStartListener
      task-created:
        enabled: true
        class: com.lingflow.listener.TaskCreatedListener

    # 任务提交处理器
    task-handlers:
      user-task-to-user-task:
        enabled: true
        class: com.lingflow.handler.UserTaskToUserTaskHandler
        order: 1
      user-task-to-parallel-gateway:
        enabled: true
        class: com.lingflow.handler.UserTaskToParallelGatewayHandler
        order: 2
      multi-instance-to-call-activity:
        enabled: true
        class: com.lingflow.handler.MultiInstanceToCallActivityHandler
        order: 3
```

### 5.2 配置类

```java
/**
 * 扩展配置类
 */
@ConfigurationProperties(prefix = "lingflow.extension")
@Data
public class ExtensionProperties {

    /**
     * 是否启用扩展
     */
    private boolean enabled = true;

    /**
     * 包装器配置
     */
    private Map<String, WrapperConfig> wrappers = new HashMap<>();

    /**
     * 事件监听器配置
     */
    private Map<String, EventListenerConfig> eventListeners = new HashMap<>();

    /**
     * 任务处理器配置
     */
    private Map<String, TaskHandlerConfig> taskHandlers = new HashMap<>();

    @Data
    public static class WrapperConfig {
        private boolean enabled = true;
        private int order = 0;
    }

    @Data
    public static class EventListenerConfig {
        private boolean enabled = true;
        private String className;
    }

    @Data
    public static class TaskHandlerConfig {
        private boolean enabled = true;
        private String className;
        private int order = 0;
    }
}
```

---

## 6. 自定义扩展示例

### 6.1 自定义包装器

```java
/**
 * 自定义业务日志包装器
 */
@Component
@ConditionalOnProperty(
    name = "lingflow.extension.wrappers.custom-business.enabled",
    havingValue = "true"
)
public class CustomBusinessLogWrapper implements FlowableServiceWrapper {

    @Autowired
    private BusinessLogService businessLogService;

    @Override
    public void after(String operation, Object result, Object... args) {
        // 记录自定义业务日志
        businessLogService.log(operation, result, args);
    }

    @Override
    public boolean supports(String operation) {
        // 只处理特定操作
        return Set.of(
            "TaskService.complete",
            "RuntimeService.startProcessInstanceByKey"
        ).contains(operation);
    }
}
```

### 6.2 自定义事件监听器

```java
/**
 * 自定义流程完成监听器
 */
@Component
@ConditionalOnProperty(
    name = "lingflow.extension.event-listeners.custom-process-end.enabled",
    havingValue = "true"
)
public class CustomProcessEndListener implements ProcessEventListener {

    @Override
    public void onAfter(ProcessEvent event) {
        String processInstanceId = event.getProcessInstanceId();

        // 执行自定义业务逻辑
        // 例如：归档流程数据、同步到其他系统等
        archiveProcessData(processInstanceId);
        syncToExternalSystem(processInstanceId);
    }

    @Override
    public boolean supports(String eventType) {
        return "PROCESS_END".equals(eventType);
    }
}
```

### 6.3 自定义提交处理器

```java
/**
 * 自定义提交处理器
 */
@Component
@SupportedNodeTypes({NodeType.USER_TASK})
@ConditionalOnProperty(
    name = "lingflow.extension.task-handlers.custom-handler.enabled",
    havingValue = "true"
)
public class CustomTaskCompletionHandler implements TaskCompletionHandler {

    @Override
    public boolean supports(TaskCompletionContext context) {
        // 自定义支持条件
        return context.getCurrentNodeType() == NodeType.USER_TASK
            && context.getVariables().containsKey("customFlag");
    }

    @Override
    public void handle(TaskCompletionContext context) {
        // 自定义处理逻辑
        String customFlag = (String) context.getVariables().get("customFlag");

        if ("special".equals(customFlag)) {
            handleSpecialCase(context);
        } else {
            handleNormalCase(context);
        }
    }
}
```

---

## 7. 扩展性最佳实践

### 7.1 包装器开发规范

1. **单一职责**：每个包装器只关注一个横切关注点
2. **无状态**：包装器应该是无状态的，避免使用实例变量
3. **性能优先**：避免在包装器中进行耗时操作
4. **异常安全**：包装器中的异常不应影响主流程

### 7.2 事件监听器开发规范

1. **快速失败**：不支持的事件应快速返回
2. **幂等性**：监听器应该是幂等的，重复执行不应产生副作用
3. **异步处理**：耗时操作应异步执行
4. **异常隔离**：监听器异常不应影响其他监听器

### 7.3 提交处理器开发规范

1. **明确优先级**：通过 getOrder() 设置合理的优先级
2. **完整处理**：实现所有生命周期方法
3. **回滚支持**：异常时能够回滚已执行的操作
4. **文档完善**：清晰说明处理器支持的场景

---

## 8. 总结

通过以上三种扩展性设计：

1. **Flowable API 封装**：统一的包装器机制，支持调用前后扩展
2. **流程事件机制**：灵活的事件监听器，支持事件前后扩展
3. **任务提交组合逻辑**：强大的处理器链，支持复杂流转逻辑

系统具有了强大的扩展能力，可以满足各种复杂的业务需求。
